# 2001. 파리퇴치 (`D2`)
## 문제

```
N x N 배열 안의 숫자는 해당 영역에 존재하는 파리의 개수를 의미한다.

M x M 크기의 파리채를 한 번 내리쳐 최대한 많은 파리를 죽이고자 한다.

죽은 파리의 개수를 구하라!
```

## 제약 사항
```
1. N 은 5 이상 15 이하이다.

2. M은 2 이상 N 이하이다.

3. 각 영역의 파리 갯수는 30 이하 이다.
```

## 입력

```
가장 첫 줄에는 테스트 케이스의 개수 T가 주어지고, 그 아래로 각 테스트 케이스가 주어진다.

각 테스트 케이스의 첫 번째 줄에 N 과 M 이 주어지고,

다음 N 줄에 걸쳐 N x N 배열이 주어진다.
```

## 출력

```
출력의 각 줄은 '#t'로 시작하고, 공백을 한 칸 둔 다음 정답을 출력한다.

(t는 테스트 케이스의 번호를 의미하며 1부터 시작한다.)
```

## 정답 및 설명
### Code

```c++
#include <iostream>
using namespace std;
 
int main()
{
    int test_case_num, cell[15][15], N, M;
    int max, sum;
 
    cin >> test_case_num;
 
    for (int i = 0; i < test_case_num; i++)
    {
        cin >> N >> M;
 
        max = 0;
 
        for (int j = 0; j < N; j++)
            for (int z = 0; z < N; z++)
                cin >> cell[j][z];
 
        for (int j = 0; j <= N - M; j++)
            for (int z = 0; z <= N - M; z++)
            {
                sum = 0;
                for (int x = j; x < j + M; x++)
                    for (int y = z; y < z + M; y++)
                        sum += cell[x][y];
 
                if (max < sum)
                    max = sum;
            }
        cout << "#" << i + 1 << " " << max << endl;
    }
    return 0;
}
```

### 변수 설명

```
int test_case_num : 테스트 케이스 반복 횟수이다.

int cell[15][15] : 파리의 숫자가 들어있는 배열이다.

int N : 입력 받아 N * N 만큼의 배열을 만든다.

int M : 입력 받아 M * M 크기의 파리채를 만든다.

int max : 가장 큰 경우의 수를 담는다.

int sum : for문 안에서만 사용하는 M * M 크기의 값을 담는 일회용 변수이다.
```

### 상세 설명

```
N, M, 배열 입력을 모두 받은 후에 4중 for문을 통한 방법으로 구현했다.

여기서 첫 번째와 두 번째 for문을 보자.

j <= N - M, z <= N - M의 만큼만 반복을 하는 것을 볼 수 있다.

M만큼을 빼 준 이유는 배열의 범위를 넘어서 참조하면 안되기 떄문이다.

그 다음 세 번쨰와 네 번쨰 for문을 보자.

반복을 돌면서 배열의 원소 중 하나를 참조해서 그 배열을 왼쪽 위 끝으로 하는 M * M 크기의 사각형 내부의 값을 더하는 방식이다.

이렇게 모든 경우의 사각형 내부 값을 구한 뒤 max 값과 비교하는 과정을 통해 가장 큰 값을 찾는다.
```